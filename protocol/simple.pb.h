// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: simple.proto

#ifndef PROTOBUF_simple_2eproto__INCLUDED
#define PROTOBUF_simple_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace lol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_simple_2eproto();
void protobuf_AssignDesc_simple_2eproto();
void protobuf_ShutdownFile_simple_2eproto();

class MSvrInfo;
class SSRegisterSvr;
class MMachineInfo;
class SSLogin;
class SaveRoleData;
class Db2GameLogin;

enum CSProtocol {
  REGISTERSVR = 4000,
  SVR_GAME2DB_LOGIN2 = 65530,
  SVR_DB2GAME_LOGIN2 = 65531
};
bool CSProtocol_IsValid(int value);
const CSProtocol CSProtocol_MIN = REGISTERSVR;
const CSProtocol CSProtocol_MAX = SVR_DB2GAME_LOGIN2;
const int CSProtocol_ARRAYSIZE = CSProtocol_MAX + 1;

const ::google::protobuf::EnumDescriptor* CSProtocol_descriptor();
inline const ::std::string& CSProtocol_Name(CSProtocol value) {
  return ::google::protobuf::internal::NameOfEnum(
    CSProtocol_descriptor(), value);
}
inline bool CSProtocol_Parse(
    const ::std::string& name, CSProtocol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CSProtocol>(
    CSProtocol_descriptor(), name, value);
}
enum ESvrType {
  ESVR_NONE = 0,
  ESVR_GAME = 1,
  ESVR_CENTER = 2,
  ESVR_GATE = 3,
  ESVR_MAIL = 4,
  ESVR_DB = 5,
  ESVR_GM = 6
};
bool ESvrType_IsValid(int value);
const ESvrType ESvrType_MIN = ESVR_NONE;
const ESvrType ESvrType_MAX = ESVR_GM;
const int ESvrType_ARRAYSIZE = ESvrType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ESvrType_descriptor();
inline const ::std::string& ESvrType_Name(ESvrType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ESvrType_descriptor(), value);
}
inline bool ESvrType_Parse(
    const ::std::string& name, ESvrType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ESvrType>(
    ESvrType_descriptor(), name, value);
}
// ===================================================================

class MSvrInfo : public ::google::protobuf::Message {
 public:
  MSvrInfo();
  virtual ~MSvrInfo();

  MSvrInfo(const MSvrInfo& from);

  inline MSvrInfo& operator=(const MSvrInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MSvrInfo& default_instance();

  void Swap(MSvrInfo* other);

  // implements Message ----------------------------------------------

  MSvrInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MSvrInfo& from);
  void MergeFrom(const MSvrInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .lol.ESvrType svrType = 1;
  inline bool has_svrtype() const;
  inline void clear_svrtype();
  static const int kSvrTypeFieldNumber = 1;
  inline ::lol::ESvrType svrtype() const;
  inline void set_svrtype(::lol::ESvrType value);

  // optional uint32 svrIndex = 2;
  inline bool has_svrindex() const;
  inline void clear_svrindex();
  static const int kSvrIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 svrindex() const;
  inline void set_svrindex(::google::protobuf::uint32 value);

  // optional string strIp = 3;
  inline bool has_strip() const;
  inline void clear_strip();
  static const int kStrIpFieldNumber = 3;
  inline const ::std::string& strip() const;
  inline void set_strip(const ::std::string& value);
  inline void set_strip(const char* value);
  inline void set_strip(const char* value, size_t size);
  inline ::std::string* mutable_strip();
  inline ::std::string* release_strip();
  inline void set_allocated_strip(::std::string* strip);

  // optional uint32 svrPort = 4;
  inline bool has_svrport() const;
  inline void clear_svrport();
  static const int kSvrPortFieldNumber = 4;
  inline ::google::protobuf::uint32 svrport() const;
  inline void set_svrport(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:lol.MSvrInfo)
 private:
  inline void set_has_svrtype();
  inline void clear_has_svrtype();
  inline void set_has_svrindex();
  inline void clear_has_svrindex();
  inline void set_has_strip();
  inline void clear_has_strip();
  inline void set_has_svrport();
  inline void clear_has_svrport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int svrtype_;
  ::google::protobuf::uint32 svrindex_;
  ::std::string* strip_;
  ::google::protobuf::uint32 svrport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static MSvrInfo* default_instance_;
};
// -------------------------------------------------------------------

class SSRegisterSvr : public ::google::protobuf::Message {
 public:
  SSRegisterSvr();
  virtual ~SSRegisterSvr();

  SSRegisterSvr(const SSRegisterSvr& from);

  inline SSRegisterSvr& operator=(const SSRegisterSvr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SSRegisterSvr& default_instance();

  void Swap(SSRegisterSvr* other);

  // implements Message ----------------------------------------------

  SSRegisterSvr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SSRegisterSvr& from);
  void MergeFrom(const SSRegisterSvr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .lol.MSvrInfo svrInfo = 1;
  inline bool has_svrinfo() const;
  inline void clear_svrinfo();
  static const int kSvrInfoFieldNumber = 1;
  inline const ::lol::MSvrInfo& svrinfo() const;
  inline ::lol::MSvrInfo* mutable_svrinfo();
  inline ::lol::MSvrInfo* release_svrinfo();
  inline void set_allocated_svrinfo(::lol::MSvrInfo* svrinfo);

  // @@protoc_insertion_point(class_scope:lol.SSRegisterSvr)
 private:
  inline void set_has_svrinfo();
  inline void clear_has_svrinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::lol::MSvrInfo* svrinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static SSRegisterSvr* default_instance_;
};
// -------------------------------------------------------------------

class MMachineInfo : public ::google::protobuf::Message {
 public:
  MMachineInfo();
  virtual ~MMachineInfo();

  MMachineInfo(const MMachineInfo& from);

  inline MMachineInfo& operator=(const MMachineInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MMachineInfo& default_instance();

  void Swap(MMachineInfo* other);

  // implements Message ----------------------------------------------

  MMachineInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MMachineInfo& from);
  void MergeFrom(const MMachineInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 os = 1;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 1;
  inline ::google::protobuf::uint32 os() const;
  inline void set_os(::google::protobuf::uint32 value);

  // optional string platform = 2;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 2;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void set_allocated_platform(::std::string* platform);

  // optional string language = 3;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 3;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional string userId = 4;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 4;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // optional string udid = 5;
  inline bool has_udid() const;
  inline void clear_udid();
  static const int kUdidFieldNumber = 5;
  inline const ::std::string& udid() const;
  inline void set_udid(const ::std::string& value);
  inline void set_udid(const char* value);
  inline void set_udid(const char* value, size_t size);
  inline ::std::string* mutable_udid();
  inline ::std::string* release_udid();
  inline void set_allocated_udid(::std::string* udid);

  // optional string deviceModel = 6;
  inline bool has_devicemodel() const;
  inline void clear_devicemodel();
  static const int kDeviceModelFieldNumber = 6;
  inline const ::std::string& devicemodel() const;
  inline void set_devicemodel(const ::std::string& value);
  inline void set_devicemodel(const char* value);
  inline void set_devicemodel(const char* value, size_t size);
  inline ::std::string* mutable_devicemodel();
  inline ::std::string* release_devicemodel();
  inline void set_allocated_devicemodel(::std::string* devicemodel);

  // optional string deviceSys = 7;
  inline bool has_devicesys() const;
  inline void clear_devicesys();
  static const int kDeviceSysFieldNumber = 7;
  inline const ::std::string& devicesys() const;
  inline void set_devicesys(const ::std::string& value);
  inline void set_devicesys(const char* value);
  inline void set_devicesys(const char* value, size_t size);
  inline ::std::string* mutable_devicesys();
  inline ::std::string* release_devicesys();
  inline void set_allocated_devicesys(::std::string* devicesys);

  // optional uint32 deviceRam = 8;
  inline bool has_deviceram() const;
  inline void clear_deviceram();
  static const int kDeviceRamFieldNumber = 8;
  inline ::google::protobuf::uint32 deviceram() const;
  inline void set_deviceram(::google::protobuf::uint32 value);

  // optional string ip = 9;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 9;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:lol.MMachineInfo)
 private:
  inline void set_has_os();
  inline void clear_has_os();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_udid();
  inline void clear_has_udid();
  inline void set_has_devicemodel();
  inline void clear_has_devicemodel();
  inline void set_has_devicesys();
  inline void clear_has_devicesys();
  inline void set_has_deviceram();
  inline void clear_has_deviceram();
  inline void set_has_ip();
  inline void clear_has_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* platform_;
  ::std::string* language_;
  ::std::string* userid_;
  ::google::protobuf::uint32 os_;
  ::google::protobuf::uint32 deviceram_;
  ::std::string* udid_;
  ::std::string* devicemodel_;
  ::std::string* devicesys_;
  ::std::string* ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static MMachineInfo* default_instance_;
};
// -------------------------------------------------------------------

class SSLogin : public ::google::protobuf::Message {
 public:
  SSLogin();
  virtual ~SSLogin();

  SSLogin(const SSLogin& from);

  inline SSLogin& operator=(const SSLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SSLogin& default_instance();

  void Swap(SSLogin* other);

  // implements Message ----------------------------------------------

  SSLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SSLogin& from);
  void MergeFrom(const SSLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional int32 gs_id = 2;
  inline bool has_gs_id() const;
  inline void clear_gs_id();
  static const int kGsIdFieldNumber = 2;
  inline ::google::protobuf::int32 gs_id() const;
  inline void set_gs_id(::google::protobuf::int32 value);

  // optional uint32 bReConnect = 3;
  inline bool has_breconnect() const;
  inline void clear_breconnect();
  static const int kBReConnectFieldNumber = 3;
  inline ::google::protobuf::uint32 breconnect() const;
  inline void set_breconnect(::google::protobuf::uint32 value);

  // optional uint32 netId = 4;
  inline bool has_netid() const;
  inline void clear_netid();
  static const int kNetIdFieldNumber = 4;
  inline ::google::protobuf::uint32 netid() const;
  inline void set_netid(::google::protobuf::uint32 value);

  // optional uint64 playerId = 5;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 5;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // optional uint32 gateLine = 6;
  inline bool has_gateline() const;
  inline void clear_gateline();
  static const int kGateLineFieldNumber = 6;
  inline ::google::protobuf::uint32 gateline() const;
  inline void set_gateline(::google::protobuf::uint32 value);

  // optional uint32 channel = 7;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 7;
  inline ::google::protobuf::uint32 channel() const;
  inline void set_channel(::google::protobuf::uint32 value);

  // optional .lol.MMachineInfo machineInfo = 8;
  inline bool has_machineinfo() const;
  inline void clear_machineinfo();
  static const int kMachineInfoFieldNumber = 8;
  inline const ::lol::MMachineInfo& machineinfo() const;
  inline ::lol::MMachineInfo* mutable_machineinfo();
  inline ::lol::MMachineInfo* release_machineinfo();
  inline void set_allocated_machineinfo(::lol::MMachineInfo* machineinfo);

  // @@protoc_insertion_point(class_scope:lol.SSLogin)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_gs_id();
  inline void clear_has_gs_id();
  inline void set_has_breconnect();
  inline void clear_has_breconnect();
  inline void set_has_netid();
  inline void clear_has_netid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_gateline();
  inline void clear_has_gateline();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_machineinfo();
  inline void clear_has_machineinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::google::protobuf::int32 gs_id_;
  ::google::protobuf::uint32 breconnect_;
  ::google::protobuf::uint64 playerid_;
  ::google::protobuf::uint32 netid_;
  ::google::protobuf::uint32 gateline_;
  ::lol::MMachineInfo* machineinfo_;
  ::google::protobuf::uint32 channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static SSLogin* default_instance_;
};
// -------------------------------------------------------------------

class SaveRoleData : public ::google::protobuf::Message {
 public:
  SaveRoleData();
  virtual ~SaveRoleData();

  SaveRoleData(const SaveRoleData& from);

  inline SaveRoleData& operator=(const SaveRoleData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SaveRoleData& default_instance();

  void Swap(SaveRoleData* other);

  // implements Message ----------------------------------------------

  SaveRoleData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SaveRoleData& from);
  void MergeFrom(const SaveRoleData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 playerId = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional uint32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional string roleName = 4;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRoleNameFieldNumber = 4;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const char* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  inline void set_allocated_rolename(::std::string* rolename);

  // optional string nickName = 5;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 5;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional int64 createTime = 6;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreateTimeFieldNumber = 6;
  inline ::google::protobuf::int64 createtime() const;
  inline void set_createtime(::google::protobuf::int64 value);

  // optional uint32 vipLevel = 7;
  inline bool has_viplevel() const;
  inline void clear_viplevel();
  static const int kVipLevelFieldNumber = 7;
  inline ::google::protobuf::uint32 viplevel() const;
  inline void set_viplevel(::google::protobuf::uint32 value);

  // optional uint32 vipExp = 8;
  inline bool has_vipexp() const;
  inline void clear_vipexp();
  static const int kVipExpFieldNumber = 8;
  inline ::google::protobuf::uint32 vipexp() const;
  inline void set_vipexp(::google::protobuf::uint32 value);

  // optional uint32 diamond = 9;
  inline bool has_diamond() const;
  inline void clear_diamond();
  static const int kDiamondFieldNumber = 9;
  inline ::google::protobuf::uint32 diamond() const;
  inline void set_diamond(::google::protobuf::uint32 value);

  // optional int64 loginTime = 10;
  inline bool has_logintime() const;
  inline void clear_logintime();
  static const int kLoginTimeFieldNumber = 10;
  inline ::google::protobuf::int64 logintime() const;
  inline void set_logintime(::google::protobuf::int64 value);

  // optional int64 offlineTime = 11;
  inline bool has_offlinetime() const;
  inline void clear_offlinetime();
  static const int kOfflineTimeFieldNumber = 11;
  inline ::google::protobuf::int64 offlinetime() const;
  inline void set_offlinetime(::google::protobuf::int64 value);

  // optional bytes heroBag = 12;
  inline bool has_herobag() const;
  inline void clear_herobag();
  static const int kHeroBagFieldNumber = 12;
  inline const ::std::string& herobag() const;
  inline void set_herobag(const ::std::string& value);
  inline void set_herobag(const char* value);
  inline void set_herobag(const void* value, size_t size);
  inline ::std::string* mutable_herobag();
  inline ::std::string* release_herobag();
  inline void set_allocated_herobag(::std::string* herobag);

  // optional bytes itemBag = 13;
  inline bool has_itembag() const;
  inline void clear_itembag();
  static const int kItemBagFieldNumber = 13;
  inline const ::std::string& itembag() const;
  inline void set_itembag(const ::std::string& value);
  inline void set_itembag(const char* value);
  inline void set_itembag(const void* value, size_t size);
  inline ::std::string* mutable_itembag();
  inline ::std::string* release_itembag();
  inline void set_allocated_itembag(::std::string* itembag);

  // optional bytes gameCopy = 14;
  inline bool has_gamecopy() const;
  inline void clear_gamecopy();
  static const int kGameCopyFieldNumber = 14;
  inline const ::std::string& gamecopy() const;
  inline void set_gamecopy(const ::std::string& value);
  inline void set_gamecopy(const char* value);
  inline void set_gamecopy(const void* value, size_t size);
  inline ::std::string* mutable_gamecopy();
  inline ::std::string* release_gamecopy();
  inline void set_allocated_gamecopy(::std::string* gamecopy);

  // optional bytes task = 15;
  inline bool has_task() const;
  inline void clear_task();
  static const int kTaskFieldNumber = 15;
  inline const ::std::string& task() const;
  inline void set_task(const ::std::string& value);
  inline void set_task(const char* value);
  inline void set_task(const void* value, size_t size);
  inline ::std::string* mutable_task();
  inline ::std::string* release_task();
  inline void set_allocated_task(::std::string* task);

  // optional bytes gameShop = 16;
  inline bool has_gameshop() const;
  inline void clear_gameshop();
  static const int kGameShopFieldNumber = 16;
  inline const ::std::string& gameshop() const;
  inline void set_gameshop(const ::std::string& value);
  inline void set_gameshop(const char* value);
  inline void set_gameshop(const void* value, size_t size);
  inline ::std::string* mutable_gameshop();
  inline ::std::string* release_gameshop();
  inline void set_allocated_gameshop(::std::string* gameshop);

  // optional bytes groupData = 17;
  inline bool has_groupdata() const;
  inline void clear_groupdata();
  static const int kGroupDataFieldNumber = 17;
  inline const ::std::string& groupdata() const;
  inline void set_groupdata(const ::std::string& value);
  inline void set_groupdata(const char* value);
  inline void set_groupdata(const void* value, size_t size);
  inline ::std::string* mutable_groupdata();
  inline ::std::string* release_groupdata();
  inline void set_allocated_groupdata(::std::string* groupdata);

  // optional uint32 gsId = 18;
  inline bool has_gsid() const;
  inline void clear_gsid();
  static const int kGsIdFieldNumber = 18;
  inline ::google::protobuf::uint32 gsid() const;
  inline void set_gsid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:lol.SaveRoleData)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_rolename();
  inline void clear_has_rolename();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_viplevel();
  inline void clear_has_viplevel();
  inline void set_has_vipexp();
  inline void clear_has_vipexp();
  inline void set_has_diamond();
  inline void clear_has_diamond();
  inline void set_has_logintime();
  inline void clear_has_logintime();
  inline void set_has_offlinetime();
  inline void clear_has_offlinetime();
  inline void set_has_herobag();
  inline void clear_has_herobag();
  inline void set_has_itembag();
  inline void clear_has_itembag();
  inline void set_has_gamecopy();
  inline void clear_has_gamecopy();
  inline void set_has_task();
  inline void clear_has_task();
  inline void set_has_gameshop();
  inline void clear_has_gameshop();
  inline void set_has_groupdata();
  inline void clear_has_groupdata();
  inline void set_has_gsid();
  inline void clear_has_gsid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerid_;
  ::std::string* account_;
  ::std::string* rolename_;
  ::std::string* nickname_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 viplevel_;
  ::google::protobuf::int64 createtime_;
  ::google::protobuf::uint32 vipexp_;
  ::google::protobuf::uint32 diamond_;
  ::google::protobuf::int64 logintime_;
  ::google::protobuf::int64 offlinetime_;
  ::std::string* herobag_;
  ::std::string* itembag_;
  ::std::string* gamecopy_;
  ::std::string* task_;
  ::std::string* gameshop_;
  ::std::string* groupdata_;
  ::google::protobuf::uint32 gsid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static SaveRoleData* default_instance_;
};
// -------------------------------------------------------------------

class Db2GameLogin : public ::google::protobuf::Message {
 public:
  Db2GameLogin();
  virtual ~Db2GameLogin();

  Db2GameLogin(const Db2GameLogin& from);

  inline Db2GameLogin& operator=(const Db2GameLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Db2GameLogin& default_instance();

  void Swap(Db2GameLogin* other);

  // implements Message ----------------------------------------------

  Db2GameLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Db2GameLogin& from);
  void MergeFrom(const Db2GameLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .lol.SaveRoleData roleData = 1;
  inline bool has_roledata() const;
  inline void clear_roledata();
  static const int kRoleDataFieldNumber = 1;
  inline const ::lol::SaveRoleData& roledata() const;
  inline ::lol::SaveRoleData* mutable_roledata();
  inline ::lol::SaveRoleData* release_roledata();
  inline void set_allocated_roledata(::lol::SaveRoleData* roledata);

  // optional uint32 netId = 2;
  inline bool has_netid() const;
  inline void clear_netid();
  static const int kNetIdFieldNumber = 2;
  inline ::google::protobuf::uint32 netid() const;
  inline void set_netid(::google::protobuf::uint32 value);

  // optional uint32 gateLine = 3;
  inline bool has_gateline() const;
  inline void clear_gateline();
  static const int kGateLineFieldNumber = 3;
  inline ::google::protobuf::uint32 gateline() const;
  inline void set_gateline(::google::protobuf::uint32 value);

  // optional uint32 reconnect = 4;
  inline bool has_reconnect() const;
  inline void clear_reconnect();
  static const int kReconnectFieldNumber = 4;
  inline ::google::protobuf::uint32 reconnect() const;
  inline void set_reconnect(::google::protobuf::uint32 value);

  // optional uint32 channel = 5;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 5;
  inline ::google::protobuf::uint32 channel() const;
  inline void set_channel(::google::protobuf::uint32 value);

  // optional .lol.MMachineInfo machineInfo = 6;
  inline bool has_machineinfo() const;
  inline void clear_machineinfo();
  static const int kMachineInfoFieldNumber = 6;
  inline const ::lol::MMachineInfo& machineinfo() const;
  inline ::lol::MMachineInfo* mutable_machineinfo();
  inline ::lol::MMachineInfo* release_machineinfo();
  inline void set_allocated_machineinfo(::lol::MMachineInfo* machineinfo);

  // @@protoc_insertion_point(class_scope:lol.Db2GameLogin)
 private:
  inline void set_has_roledata();
  inline void clear_has_roledata();
  inline void set_has_netid();
  inline void clear_has_netid();
  inline void set_has_gateline();
  inline void clear_has_gateline();
  inline void set_has_reconnect();
  inline void clear_has_reconnect();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_machineinfo();
  inline void clear_has_machineinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::lol::SaveRoleData* roledata_;
  ::google::protobuf::uint32 netid_;
  ::google::protobuf::uint32 gateline_;
  ::google::protobuf::uint32 reconnect_;
  ::google::protobuf::uint32 channel_;
  ::lol::MMachineInfo* machineinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static Db2GameLogin* default_instance_;
};
// ===================================================================


// ===================================================================

// MSvrInfo

// optional .lol.ESvrType svrType = 1;
inline bool MSvrInfo::has_svrtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSvrInfo::set_has_svrtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MSvrInfo::clear_has_svrtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MSvrInfo::clear_svrtype() {
  svrtype_ = 0;
  clear_has_svrtype();
}
inline ::lol::ESvrType MSvrInfo::svrtype() const {
  return static_cast< ::lol::ESvrType >(svrtype_);
}
inline void MSvrInfo::set_svrtype(::lol::ESvrType value) {
  assert(::lol::ESvrType_IsValid(value));
  set_has_svrtype();
  svrtype_ = value;
}

// optional uint32 svrIndex = 2;
inline bool MSvrInfo::has_svrindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MSvrInfo::set_has_svrindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MSvrInfo::clear_has_svrindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MSvrInfo::clear_svrindex() {
  svrindex_ = 0u;
  clear_has_svrindex();
}
inline ::google::protobuf::uint32 MSvrInfo::svrindex() const {
  return svrindex_;
}
inline void MSvrInfo::set_svrindex(::google::protobuf::uint32 value) {
  set_has_svrindex();
  svrindex_ = value;
}

// optional string strIp = 3;
inline bool MSvrInfo::has_strip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MSvrInfo::set_has_strip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MSvrInfo::clear_has_strip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MSvrInfo::clear_strip() {
  if (strip_ != &::google::protobuf::internal::kEmptyString) {
    strip_->clear();
  }
  clear_has_strip();
}
inline const ::std::string& MSvrInfo::strip() const {
  return *strip_;
}
inline void MSvrInfo::set_strip(const ::std::string& value) {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  strip_->assign(value);
}
inline void MSvrInfo::set_strip(const char* value) {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  strip_->assign(value);
}
inline void MSvrInfo::set_strip(const char* value, size_t size) {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  strip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MSvrInfo::mutable_strip() {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  return strip_;
}
inline ::std::string* MSvrInfo::release_strip() {
  clear_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strip_;
    strip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MSvrInfo::set_allocated_strip(::std::string* strip) {
  if (strip_ != &::google::protobuf::internal::kEmptyString) {
    delete strip_;
  }
  if (strip) {
    set_has_strip();
    strip_ = strip;
  } else {
    clear_has_strip();
    strip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 svrPort = 4;
inline bool MSvrInfo::has_svrport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MSvrInfo::set_has_svrport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MSvrInfo::clear_has_svrport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MSvrInfo::clear_svrport() {
  svrport_ = 0u;
  clear_has_svrport();
}
inline ::google::protobuf::uint32 MSvrInfo::svrport() const {
  return svrport_;
}
inline void MSvrInfo::set_svrport(::google::protobuf::uint32 value) {
  set_has_svrport();
  svrport_ = value;
}

// -------------------------------------------------------------------

// SSRegisterSvr

// optional .lol.MSvrInfo svrInfo = 1;
inline bool SSRegisterSvr::has_svrinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SSRegisterSvr::set_has_svrinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SSRegisterSvr::clear_has_svrinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SSRegisterSvr::clear_svrinfo() {
  if (svrinfo_ != NULL) svrinfo_->::lol::MSvrInfo::Clear();
  clear_has_svrinfo();
}
inline const ::lol::MSvrInfo& SSRegisterSvr::svrinfo() const {
  return svrinfo_ != NULL ? *svrinfo_ : *default_instance_->svrinfo_;
}
inline ::lol::MSvrInfo* SSRegisterSvr::mutable_svrinfo() {
  set_has_svrinfo();
  if (svrinfo_ == NULL) svrinfo_ = new ::lol::MSvrInfo;
  return svrinfo_;
}
inline ::lol::MSvrInfo* SSRegisterSvr::release_svrinfo() {
  clear_has_svrinfo();
  ::lol::MSvrInfo* temp = svrinfo_;
  svrinfo_ = NULL;
  return temp;
}
inline void SSRegisterSvr::set_allocated_svrinfo(::lol::MSvrInfo* svrinfo) {
  delete svrinfo_;
  svrinfo_ = svrinfo;
  if (svrinfo) {
    set_has_svrinfo();
  } else {
    clear_has_svrinfo();
  }
}

// -------------------------------------------------------------------

// MMachineInfo

// optional uint32 os = 1;
inline bool MMachineInfo::has_os() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MMachineInfo::set_has_os() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MMachineInfo::clear_has_os() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MMachineInfo::clear_os() {
  os_ = 0u;
  clear_has_os();
}
inline ::google::protobuf::uint32 MMachineInfo::os() const {
  return os_;
}
inline void MMachineInfo::set_os(::google::protobuf::uint32 value) {
  set_has_os();
  os_ = value;
}

// optional string platform = 2;
inline bool MMachineInfo::has_platform() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MMachineInfo::set_has_platform() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MMachineInfo::clear_has_platform() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MMachineInfo::clear_platform() {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    platform_->clear();
  }
  clear_has_platform();
}
inline const ::std::string& MMachineInfo::platform() const {
  return *platform_;
}
inline void MMachineInfo::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void MMachineInfo::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void MMachineInfo::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMachineInfo::mutable_platform() {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  return platform_;
}
inline ::std::string* MMachineInfo::release_platform() {
  clear_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMachineInfo::set_allocated_platform(::std::string* platform) {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    delete platform_;
  }
  if (platform) {
    set_has_platform();
    platform_ = platform;
  } else {
    clear_has_platform();
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string language = 3;
inline bool MMachineInfo::has_language() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MMachineInfo::set_has_language() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MMachineInfo::clear_has_language() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MMachineInfo::clear_language() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& MMachineInfo::language() const {
  return *language_;
}
inline void MMachineInfo::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void MMachineInfo::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void MMachineInfo::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMachineInfo::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  return language_;
}
inline ::std::string* MMachineInfo::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMachineInfo::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string userId = 4;
inline bool MMachineInfo::has_userid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MMachineInfo::set_has_userid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MMachineInfo::clear_has_userid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MMachineInfo::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& MMachineInfo::userid() const {
  return *userid_;
}
inline void MMachineInfo::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void MMachineInfo::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void MMachineInfo::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMachineInfo::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* MMachineInfo::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMachineInfo::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string udid = 5;
inline bool MMachineInfo::has_udid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MMachineInfo::set_has_udid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MMachineInfo::clear_has_udid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MMachineInfo::clear_udid() {
  if (udid_ != &::google::protobuf::internal::kEmptyString) {
    udid_->clear();
  }
  clear_has_udid();
}
inline const ::std::string& MMachineInfo::udid() const {
  return *udid_;
}
inline void MMachineInfo::set_udid(const ::std::string& value) {
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  udid_->assign(value);
}
inline void MMachineInfo::set_udid(const char* value) {
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  udid_->assign(value);
}
inline void MMachineInfo::set_udid(const char* value, size_t size) {
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  udid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMachineInfo::mutable_udid() {
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  return udid_;
}
inline ::std::string* MMachineInfo::release_udid() {
  clear_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = udid_;
    udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMachineInfo::set_allocated_udid(::std::string* udid) {
  if (udid_ != &::google::protobuf::internal::kEmptyString) {
    delete udid_;
  }
  if (udid) {
    set_has_udid();
    udid_ = udid;
  } else {
    clear_has_udid();
    udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceModel = 6;
inline bool MMachineInfo::has_devicemodel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MMachineInfo::set_has_devicemodel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MMachineInfo::clear_has_devicemodel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MMachineInfo::clear_devicemodel() {
  if (devicemodel_ != &::google::protobuf::internal::kEmptyString) {
    devicemodel_->clear();
  }
  clear_has_devicemodel();
}
inline const ::std::string& MMachineInfo::devicemodel() const {
  return *devicemodel_;
}
inline void MMachineInfo::set_devicemodel(const ::std::string& value) {
  set_has_devicemodel();
  if (devicemodel_ == &::google::protobuf::internal::kEmptyString) {
    devicemodel_ = new ::std::string;
  }
  devicemodel_->assign(value);
}
inline void MMachineInfo::set_devicemodel(const char* value) {
  set_has_devicemodel();
  if (devicemodel_ == &::google::protobuf::internal::kEmptyString) {
    devicemodel_ = new ::std::string;
  }
  devicemodel_->assign(value);
}
inline void MMachineInfo::set_devicemodel(const char* value, size_t size) {
  set_has_devicemodel();
  if (devicemodel_ == &::google::protobuf::internal::kEmptyString) {
    devicemodel_ = new ::std::string;
  }
  devicemodel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMachineInfo::mutable_devicemodel() {
  set_has_devicemodel();
  if (devicemodel_ == &::google::protobuf::internal::kEmptyString) {
    devicemodel_ = new ::std::string;
  }
  return devicemodel_;
}
inline ::std::string* MMachineInfo::release_devicemodel() {
  clear_has_devicemodel();
  if (devicemodel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicemodel_;
    devicemodel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMachineInfo::set_allocated_devicemodel(::std::string* devicemodel) {
  if (devicemodel_ != &::google::protobuf::internal::kEmptyString) {
    delete devicemodel_;
  }
  if (devicemodel) {
    set_has_devicemodel();
    devicemodel_ = devicemodel;
  } else {
    clear_has_devicemodel();
    devicemodel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceSys = 7;
inline bool MMachineInfo::has_devicesys() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MMachineInfo::set_has_devicesys() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MMachineInfo::clear_has_devicesys() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MMachineInfo::clear_devicesys() {
  if (devicesys_ != &::google::protobuf::internal::kEmptyString) {
    devicesys_->clear();
  }
  clear_has_devicesys();
}
inline const ::std::string& MMachineInfo::devicesys() const {
  return *devicesys_;
}
inline void MMachineInfo::set_devicesys(const ::std::string& value) {
  set_has_devicesys();
  if (devicesys_ == &::google::protobuf::internal::kEmptyString) {
    devicesys_ = new ::std::string;
  }
  devicesys_->assign(value);
}
inline void MMachineInfo::set_devicesys(const char* value) {
  set_has_devicesys();
  if (devicesys_ == &::google::protobuf::internal::kEmptyString) {
    devicesys_ = new ::std::string;
  }
  devicesys_->assign(value);
}
inline void MMachineInfo::set_devicesys(const char* value, size_t size) {
  set_has_devicesys();
  if (devicesys_ == &::google::protobuf::internal::kEmptyString) {
    devicesys_ = new ::std::string;
  }
  devicesys_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMachineInfo::mutable_devicesys() {
  set_has_devicesys();
  if (devicesys_ == &::google::protobuf::internal::kEmptyString) {
    devicesys_ = new ::std::string;
  }
  return devicesys_;
}
inline ::std::string* MMachineInfo::release_devicesys() {
  clear_has_devicesys();
  if (devicesys_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicesys_;
    devicesys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMachineInfo::set_allocated_devicesys(::std::string* devicesys) {
  if (devicesys_ != &::google::protobuf::internal::kEmptyString) {
    delete devicesys_;
  }
  if (devicesys) {
    set_has_devicesys();
    devicesys_ = devicesys;
  } else {
    clear_has_devicesys();
    devicesys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 deviceRam = 8;
inline bool MMachineInfo::has_deviceram() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MMachineInfo::set_has_deviceram() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MMachineInfo::clear_has_deviceram() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MMachineInfo::clear_deviceram() {
  deviceram_ = 0u;
  clear_has_deviceram();
}
inline ::google::protobuf::uint32 MMachineInfo::deviceram() const {
  return deviceram_;
}
inline void MMachineInfo::set_deviceram(::google::protobuf::uint32 value) {
  set_has_deviceram();
  deviceram_ = value;
}

// optional string ip = 9;
inline bool MMachineInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MMachineInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MMachineInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MMachineInfo::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& MMachineInfo::ip() const {
  return *ip_;
}
inline void MMachineInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void MMachineInfo::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void MMachineInfo::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMachineInfo::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* MMachineInfo::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMachineInfo::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SSLogin

// optional string account = 1;
inline bool SSLogin::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SSLogin::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SSLogin::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SSLogin::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& SSLogin::account() const {
  return *account_;
}
inline void SSLogin::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void SSLogin::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void SSLogin::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SSLogin::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* SSLogin::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SSLogin::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 gs_id = 2;
inline bool SSLogin::has_gs_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SSLogin::set_has_gs_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SSLogin::clear_has_gs_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SSLogin::clear_gs_id() {
  gs_id_ = 0;
  clear_has_gs_id();
}
inline ::google::protobuf::int32 SSLogin::gs_id() const {
  return gs_id_;
}
inline void SSLogin::set_gs_id(::google::protobuf::int32 value) {
  set_has_gs_id();
  gs_id_ = value;
}

// optional uint32 bReConnect = 3;
inline bool SSLogin::has_breconnect() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SSLogin::set_has_breconnect() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SSLogin::clear_has_breconnect() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SSLogin::clear_breconnect() {
  breconnect_ = 0u;
  clear_has_breconnect();
}
inline ::google::protobuf::uint32 SSLogin::breconnect() const {
  return breconnect_;
}
inline void SSLogin::set_breconnect(::google::protobuf::uint32 value) {
  set_has_breconnect();
  breconnect_ = value;
}

// optional uint32 netId = 4;
inline bool SSLogin::has_netid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SSLogin::set_has_netid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SSLogin::clear_has_netid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SSLogin::clear_netid() {
  netid_ = 0u;
  clear_has_netid();
}
inline ::google::protobuf::uint32 SSLogin::netid() const {
  return netid_;
}
inline void SSLogin::set_netid(::google::protobuf::uint32 value) {
  set_has_netid();
  netid_ = value;
}

// optional uint64 playerId = 5;
inline bool SSLogin::has_playerid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SSLogin::set_has_playerid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SSLogin::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SSLogin::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 SSLogin::playerid() const {
  return playerid_;
}
inline void SSLogin::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional uint32 gateLine = 6;
inline bool SSLogin::has_gateline() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SSLogin::set_has_gateline() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SSLogin::clear_has_gateline() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SSLogin::clear_gateline() {
  gateline_ = 0u;
  clear_has_gateline();
}
inline ::google::protobuf::uint32 SSLogin::gateline() const {
  return gateline_;
}
inline void SSLogin::set_gateline(::google::protobuf::uint32 value) {
  set_has_gateline();
  gateline_ = value;
}

// optional uint32 channel = 7;
inline bool SSLogin::has_channel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SSLogin::set_has_channel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SSLogin::clear_has_channel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SSLogin::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 SSLogin::channel() const {
  return channel_;
}
inline void SSLogin::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
}

// optional .lol.MMachineInfo machineInfo = 8;
inline bool SSLogin::has_machineinfo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SSLogin::set_has_machineinfo() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SSLogin::clear_has_machineinfo() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SSLogin::clear_machineinfo() {
  if (machineinfo_ != NULL) machineinfo_->::lol::MMachineInfo::Clear();
  clear_has_machineinfo();
}
inline const ::lol::MMachineInfo& SSLogin::machineinfo() const {
  return machineinfo_ != NULL ? *machineinfo_ : *default_instance_->machineinfo_;
}
inline ::lol::MMachineInfo* SSLogin::mutable_machineinfo() {
  set_has_machineinfo();
  if (machineinfo_ == NULL) machineinfo_ = new ::lol::MMachineInfo;
  return machineinfo_;
}
inline ::lol::MMachineInfo* SSLogin::release_machineinfo() {
  clear_has_machineinfo();
  ::lol::MMachineInfo* temp = machineinfo_;
  machineinfo_ = NULL;
  return temp;
}
inline void SSLogin::set_allocated_machineinfo(::lol::MMachineInfo* machineinfo) {
  delete machineinfo_;
  machineinfo_ = machineinfo;
  if (machineinfo) {
    set_has_machineinfo();
  } else {
    clear_has_machineinfo();
  }
}

// -------------------------------------------------------------------

// SaveRoleData

// optional uint64 playerId = 1;
inline bool SaveRoleData::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SaveRoleData::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SaveRoleData::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SaveRoleData::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 SaveRoleData::playerid() const {
  return playerid_;
}
inline void SaveRoleData::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional string account = 2;
inline bool SaveRoleData::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SaveRoleData::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SaveRoleData::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SaveRoleData::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& SaveRoleData::account() const {
  return *account_;
}
inline void SaveRoleData::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void SaveRoleData::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void SaveRoleData::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SaveRoleData::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* SaveRoleData::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SaveRoleData::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 level = 3;
inline bool SaveRoleData::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SaveRoleData::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SaveRoleData::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SaveRoleData::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 SaveRoleData::level() const {
  return level_;
}
inline void SaveRoleData::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional string roleName = 4;
inline bool SaveRoleData::has_rolename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SaveRoleData::set_has_rolename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SaveRoleData::clear_has_rolename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SaveRoleData::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& SaveRoleData::rolename() const {
  return *rolename_;
}
inline void SaveRoleData::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void SaveRoleData::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void SaveRoleData::set_rolename(const char* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SaveRoleData::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  return rolename_;
}
inline ::std::string* SaveRoleData::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SaveRoleData::set_allocated_rolename(::std::string* rolename) {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    delete rolename_;
  }
  if (rolename) {
    set_has_rolename();
    rolename_ = rolename;
  } else {
    clear_has_rolename();
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nickName = 5;
inline bool SaveRoleData::has_nickname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SaveRoleData::set_has_nickname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SaveRoleData::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SaveRoleData::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& SaveRoleData::nickname() const {
  return *nickname_;
}
inline void SaveRoleData::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void SaveRoleData::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void SaveRoleData::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SaveRoleData::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* SaveRoleData::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SaveRoleData::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 createTime = 6;
inline bool SaveRoleData::has_createtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SaveRoleData::set_has_createtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SaveRoleData::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SaveRoleData::clear_createtime() {
  createtime_ = GOOGLE_LONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::int64 SaveRoleData::createtime() const {
  return createtime_;
}
inline void SaveRoleData::set_createtime(::google::protobuf::int64 value) {
  set_has_createtime();
  createtime_ = value;
}

// optional uint32 vipLevel = 7;
inline bool SaveRoleData::has_viplevel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SaveRoleData::set_has_viplevel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SaveRoleData::clear_has_viplevel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SaveRoleData::clear_viplevel() {
  viplevel_ = 0u;
  clear_has_viplevel();
}
inline ::google::protobuf::uint32 SaveRoleData::viplevel() const {
  return viplevel_;
}
inline void SaveRoleData::set_viplevel(::google::protobuf::uint32 value) {
  set_has_viplevel();
  viplevel_ = value;
}

// optional uint32 vipExp = 8;
inline bool SaveRoleData::has_vipexp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SaveRoleData::set_has_vipexp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SaveRoleData::clear_has_vipexp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SaveRoleData::clear_vipexp() {
  vipexp_ = 0u;
  clear_has_vipexp();
}
inline ::google::protobuf::uint32 SaveRoleData::vipexp() const {
  return vipexp_;
}
inline void SaveRoleData::set_vipexp(::google::protobuf::uint32 value) {
  set_has_vipexp();
  vipexp_ = value;
}

// optional uint32 diamond = 9;
inline bool SaveRoleData::has_diamond() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SaveRoleData::set_has_diamond() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SaveRoleData::clear_has_diamond() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SaveRoleData::clear_diamond() {
  diamond_ = 0u;
  clear_has_diamond();
}
inline ::google::protobuf::uint32 SaveRoleData::diamond() const {
  return diamond_;
}
inline void SaveRoleData::set_diamond(::google::protobuf::uint32 value) {
  set_has_diamond();
  diamond_ = value;
}

// optional int64 loginTime = 10;
inline bool SaveRoleData::has_logintime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SaveRoleData::set_has_logintime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SaveRoleData::clear_has_logintime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SaveRoleData::clear_logintime() {
  logintime_ = GOOGLE_LONGLONG(0);
  clear_has_logintime();
}
inline ::google::protobuf::int64 SaveRoleData::logintime() const {
  return logintime_;
}
inline void SaveRoleData::set_logintime(::google::protobuf::int64 value) {
  set_has_logintime();
  logintime_ = value;
}

// optional int64 offlineTime = 11;
inline bool SaveRoleData::has_offlinetime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SaveRoleData::set_has_offlinetime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SaveRoleData::clear_has_offlinetime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SaveRoleData::clear_offlinetime() {
  offlinetime_ = GOOGLE_LONGLONG(0);
  clear_has_offlinetime();
}
inline ::google::protobuf::int64 SaveRoleData::offlinetime() const {
  return offlinetime_;
}
inline void SaveRoleData::set_offlinetime(::google::protobuf::int64 value) {
  set_has_offlinetime();
  offlinetime_ = value;
}

// optional bytes heroBag = 12;
inline bool SaveRoleData::has_herobag() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SaveRoleData::set_has_herobag() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SaveRoleData::clear_has_herobag() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SaveRoleData::clear_herobag() {
  if (herobag_ != &::google::protobuf::internal::kEmptyString) {
    herobag_->clear();
  }
  clear_has_herobag();
}
inline const ::std::string& SaveRoleData::herobag() const {
  return *herobag_;
}
inline void SaveRoleData::set_herobag(const ::std::string& value) {
  set_has_herobag();
  if (herobag_ == &::google::protobuf::internal::kEmptyString) {
    herobag_ = new ::std::string;
  }
  herobag_->assign(value);
}
inline void SaveRoleData::set_herobag(const char* value) {
  set_has_herobag();
  if (herobag_ == &::google::protobuf::internal::kEmptyString) {
    herobag_ = new ::std::string;
  }
  herobag_->assign(value);
}
inline void SaveRoleData::set_herobag(const void* value, size_t size) {
  set_has_herobag();
  if (herobag_ == &::google::protobuf::internal::kEmptyString) {
    herobag_ = new ::std::string;
  }
  herobag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SaveRoleData::mutable_herobag() {
  set_has_herobag();
  if (herobag_ == &::google::protobuf::internal::kEmptyString) {
    herobag_ = new ::std::string;
  }
  return herobag_;
}
inline ::std::string* SaveRoleData::release_herobag() {
  clear_has_herobag();
  if (herobag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = herobag_;
    herobag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SaveRoleData::set_allocated_herobag(::std::string* herobag) {
  if (herobag_ != &::google::protobuf::internal::kEmptyString) {
    delete herobag_;
  }
  if (herobag) {
    set_has_herobag();
    herobag_ = herobag;
  } else {
    clear_has_herobag();
    herobag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes itemBag = 13;
inline bool SaveRoleData::has_itembag() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SaveRoleData::set_has_itembag() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SaveRoleData::clear_has_itembag() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SaveRoleData::clear_itembag() {
  if (itembag_ != &::google::protobuf::internal::kEmptyString) {
    itembag_->clear();
  }
  clear_has_itembag();
}
inline const ::std::string& SaveRoleData::itembag() const {
  return *itembag_;
}
inline void SaveRoleData::set_itembag(const ::std::string& value) {
  set_has_itembag();
  if (itembag_ == &::google::protobuf::internal::kEmptyString) {
    itembag_ = new ::std::string;
  }
  itembag_->assign(value);
}
inline void SaveRoleData::set_itembag(const char* value) {
  set_has_itembag();
  if (itembag_ == &::google::protobuf::internal::kEmptyString) {
    itembag_ = new ::std::string;
  }
  itembag_->assign(value);
}
inline void SaveRoleData::set_itembag(const void* value, size_t size) {
  set_has_itembag();
  if (itembag_ == &::google::protobuf::internal::kEmptyString) {
    itembag_ = new ::std::string;
  }
  itembag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SaveRoleData::mutable_itembag() {
  set_has_itembag();
  if (itembag_ == &::google::protobuf::internal::kEmptyString) {
    itembag_ = new ::std::string;
  }
  return itembag_;
}
inline ::std::string* SaveRoleData::release_itembag() {
  clear_has_itembag();
  if (itembag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = itembag_;
    itembag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SaveRoleData::set_allocated_itembag(::std::string* itembag) {
  if (itembag_ != &::google::protobuf::internal::kEmptyString) {
    delete itembag_;
  }
  if (itembag) {
    set_has_itembag();
    itembag_ = itembag;
  } else {
    clear_has_itembag();
    itembag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gameCopy = 14;
inline bool SaveRoleData::has_gamecopy() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SaveRoleData::set_has_gamecopy() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SaveRoleData::clear_has_gamecopy() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SaveRoleData::clear_gamecopy() {
  if (gamecopy_ != &::google::protobuf::internal::kEmptyString) {
    gamecopy_->clear();
  }
  clear_has_gamecopy();
}
inline const ::std::string& SaveRoleData::gamecopy() const {
  return *gamecopy_;
}
inline void SaveRoleData::set_gamecopy(const ::std::string& value) {
  set_has_gamecopy();
  if (gamecopy_ == &::google::protobuf::internal::kEmptyString) {
    gamecopy_ = new ::std::string;
  }
  gamecopy_->assign(value);
}
inline void SaveRoleData::set_gamecopy(const char* value) {
  set_has_gamecopy();
  if (gamecopy_ == &::google::protobuf::internal::kEmptyString) {
    gamecopy_ = new ::std::string;
  }
  gamecopy_->assign(value);
}
inline void SaveRoleData::set_gamecopy(const void* value, size_t size) {
  set_has_gamecopy();
  if (gamecopy_ == &::google::protobuf::internal::kEmptyString) {
    gamecopy_ = new ::std::string;
  }
  gamecopy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SaveRoleData::mutable_gamecopy() {
  set_has_gamecopy();
  if (gamecopy_ == &::google::protobuf::internal::kEmptyString) {
    gamecopy_ = new ::std::string;
  }
  return gamecopy_;
}
inline ::std::string* SaveRoleData::release_gamecopy() {
  clear_has_gamecopy();
  if (gamecopy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamecopy_;
    gamecopy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SaveRoleData::set_allocated_gamecopy(::std::string* gamecopy) {
  if (gamecopy_ != &::google::protobuf::internal::kEmptyString) {
    delete gamecopy_;
  }
  if (gamecopy) {
    set_has_gamecopy();
    gamecopy_ = gamecopy;
  } else {
    clear_has_gamecopy();
    gamecopy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes task = 15;
inline bool SaveRoleData::has_task() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SaveRoleData::set_has_task() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SaveRoleData::clear_has_task() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SaveRoleData::clear_task() {
  if (task_ != &::google::protobuf::internal::kEmptyString) {
    task_->clear();
  }
  clear_has_task();
}
inline const ::std::string& SaveRoleData::task() const {
  return *task_;
}
inline void SaveRoleData::set_task(const ::std::string& value) {
  set_has_task();
  if (task_ == &::google::protobuf::internal::kEmptyString) {
    task_ = new ::std::string;
  }
  task_->assign(value);
}
inline void SaveRoleData::set_task(const char* value) {
  set_has_task();
  if (task_ == &::google::protobuf::internal::kEmptyString) {
    task_ = new ::std::string;
  }
  task_->assign(value);
}
inline void SaveRoleData::set_task(const void* value, size_t size) {
  set_has_task();
  if (task_ == &::google::protobuf::internal::kEmptyString) {
    task_ = new ::std::string;
  }
  task_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SaveRoleData::mutable_task() {
  set_has_task();
  if (task_ == &::google::protobuf::internal::kEmptyString) {
    task_ = new ::std::string;
  }
  return task_;
}
inline ::std::string* SaveRoleData::release_task() {
  clear_has_task();
  if (task_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_;
    task_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SaveRoleData::set_allocated_task(::std::string* task) {
  if (task_ != &::google::protobuf::internal::kEmptyString) {
    delete task_;
  }
  if (task) {
    set_has_task();
    task_ = task;
  } else {
    clear_has_task();
    task_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gameShop = 16;
inline bool SaveRoleData::has_gameshop() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SaveRoleData::set_has_gameshop() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SaveRoleData::clear_has_gameshop() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SaveRoleData::clear_gameshop() {
  if (gameshop_ != &::google::protobuf::internal::kEmptyString) {
    gameshop_->clear();
  }
  clear_has_gameshop();
}
inline const ::std::string& SaveRoleData::gameshop() const {
  return *gameshop_;
}
inline void SaveRoleData::set_gameshop(const ::std::string& value) {
  set_has_gameshop();
  if (gameshop_ == &::google::protobuf::internal::kEmptyString) {
    gameshop_ = new ::std::string;
  }
  gameshop_->assign(value);
}
inline void SaveRoleData::set_gameshop(const char* value) {
  set_has_gameshop();
  if (gameshop_ == &::google::protobuf::internal::kEmptyString) {
    gameshop_ = new ::std::string;
  }
  gameshop_->assign(value);
}
inline void SaveRoleData::set_gameshop(const void* value, size_t size) {
  set_has_gameshop();
  if (gameshop_ == &::google::protobuf::internal::kEmptyString) {
    gameshop_ = new ::std::string;
  }
  gameshop_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SaveRoleData::mutable_gameshop() {
  set_has_gameshop();
  if (gameshop_ == &::google::protobuf::internal::kEmptyString) {
    gameshop_ = new ::std::string;
  }
  return gameshop_;
}
inline ::std::string* SaveRoleData::release_gameshop() {
  clear_has_gameshop();
  if (gameshop_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameshop_;
    gameshop_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SaveRoleData::set_allocated_gameshop(::std::string* gameshop) {
  if (gameshop_ != &::google::protobuf::internal::kEmptyString) {
    delete gameshop_;
  }
  if (gameshop) {
    set_has_gameshop();
    gameshop_ = gameshop;
  } else {
    clear_has_gameshop();
    gameshop_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes groupData = 17;
inline bool SaveRoleData::has_groupdata() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SaveRoleData::set_has_groupdata() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SaveRoleData::clear_has_groupdata() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SaveRoleData::clear_groupdata() {
  if (groupdata_ != &::google::protobuf::internal::kEmptyString) {
    groupdata_->clear();
  }
  clear_has_groupdata();
}
inline const ::std::string& SaveRoleData::groupdata() const {
  return *groupdata_;
}
inline void SaveRoleData::set_groupdata(const ::std::string& value) {
  set_has_groupdata();
  if (groupdata_ == &::google::protobuf::internal::kEmptyString) {
    groupdata_ = new ::std::string;
  }
  groupdata_->assign(value);
}
inline void SaveRoleData::set_groupdata(const char* value) {
  set_has_groupdata();
  if (groupdata_ == &::google::protobuf::internal::kEmptyString) {
    groupdata_ = new ::std::string;
  }
  groupdata_->assign(value);
}
inline void SaveRoleData::set_groupdata(const void* value, size_t size) {
  set_has_groupdata();
  if (groupdata_ == &::google::protobuf::internal::kEmptyString) {
    groupdata_ = new ::std::string;
  }
  groupdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SaveRoleData::mutable_groupdata() {
  set_has_groupdata();
  if (groupdata_ == &::google::protobuf::internal::kEmptyString) {
    groupdata_ = new ::std::string;
  }
  return groupdata_;
}
inline ::std::string* SaveRoleData::release_groupdata() {
  clear_has_groupdata();
  if (groupdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupdata_;
    groupdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SaveRoleData::set_allocated_groupdata(::std::string* groupdata) {
  if (groupdata_ != &::google::protobuf::internal::kEmptyString) {
    delete groupdata_;
  }
  if (groupdata) {
    set_has_groupdata();
    groupdata_ = groupdata;
  } else {
    clear_has_groupdata();
    groupdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 gsId = 18;
inline bool SaveRoleData::has_gsid() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SaveRoleData::set_has_gsid() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SaveRoleData::clear_has_gsid() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SaveRoleData::clear_gsid() {
  gsid_ = 0u;
  clear_has_gsid();
}
inline ::google::protobuf::uint32 SaveRoleData::gsid() const {
  return gsid_;
}
inline void SaveRoleData::set_gsid(::google::protobuf::uint32 value) {
  set_has_gsid();
  gsid_ = value;
}

// -------------------------------------------------------------------

// Db2GameLogin

// optional .lol.SaveRoleData roleData = 1;
inline bool Db2GameLogin::has_roledata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Db2GameLogin::set_has_roledata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Db2GameLogin::clear_has_roledata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Db2GameLogin::clear_roledata() {
  if (roledata_ != NULL) roledata_->::lol::SaveRoleData::Clear();
  clear_has_roledata();
}
inline const ::lol::SaveRoleData& Db2GameLogin::roledata() const {
  return roledata_ != NULL ? *roledata_ : *default_instance_->roledata_;
}
inline ::lol::SaveRoleData* Db2GameLogin::mutable_roledata() {
  set_has_roledata();
  if (roledata_ == NULL) roledata_ = new ::lol::SaveRoleData;
  return roledata_;
}
inline ::lol::SaveRoleData* Db2GameLogin::release_roledata() {
  clear_has_roledata();
  ::lol::SaveRoleData* temp = roledata_;
  roledata_ = NULL;
  return temp;
}
inline void Db2GameLogin::set_allocated_roledata(::lol::SaveRoleData* roledata) {
  delete roledata_;
  roledata_ = roledata;
  if (roledata) {
    set_has_roledata();
  } else {
    clear_has_roledata();
  }
}

// optional uint32 netId = 2;
inline bool Db2GameLogin::has_netid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Db2GameLogin::set_has_netid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Db2GameLogin::clear_has_netid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Db2GameLogin::clear_netid() {
  netid_ = 0u;
  clear_has_netid();
}
inline ::google::protobuf::uint32 Db2GameLogin::netid() const {
  return netid_;
}
inline void Db2GameLogin::set_netid(::google::protobuf::uint32 value) {
  set_has_netid();
  netid_ = value;
}

// optional uint32 gateLine = 3;
inline bool Db2GameLogin::has_gateline() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Db2GameLogin::set_has_gateline() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Db2GameLogin::clear_has_gateline() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Db2GameLogin::clear_gateline() {
  gateline_ = 0u;
  clear_has_gateline();
}
inline ::google::protobuf::uint32 Db2GameLogin::gateline() const {
  return gateline_;
}
inline void Db2GameLogin::set_gateline(::google::protobuf::uint32 value) {
  set_has_gateline();
  gateline_ = value;
}

// optional uint32 reconnect = 4;
inline bool Db2GameLogin::has_reconnect() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Db2GameLogin::set_has_reconnect() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Db2GameLogin::clear_has_reconnect() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Db2GameLogin::clear_reconnect() {
  reconnect_ = 0u;
  clear_has_reconnect();
}
inline ::google::protobuf::uint32 Db2GameLogin::reconnect() const {
  return reconnect_;
}
inline void Db2GameLogin::set_reconnect(::google::protobuf::uint32 value) {
  set_has_reconnect();
  reconnect_ = value;
}

// optional uint32 channel = 5;
inline bool Db2GameLogin::has_channel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Db2GameLogin::set_has_channel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Db2GameLogin::clear_has_channel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Db2GameLogin::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 Db2GameLogin::channel() const {
  return channel_;
}
inline void Db2GameLogin::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
}

// optional .lol.MMachineInfo machineInfo = 6;
inline bool Db2GameLogin::has_machineinfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Db2GameLogin::set_has_machineinfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Db2GameLogin::clear_has_machineinfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Db2GameLogin::clear_machineinfo() {
  if (machineinfo_ != NULL) machineinfo_->::lol::MMachineInfo::Clear();
  clear_has_machineinfo();
}
inline const ::lol::MMachineInfo& Db2GameLogin::machineinfo() const {
  return machineinfo_ != NULL ? *machineinfo_ : *default_instance_->machineinfo_;
}
inline ::lol::MMachineInfo* Db2GameLogin::mutable_machineinfo() {
  set_has_machineinfo();
  if (machineinfo_ == NULL) machineinfo_ = new ::lol::MMachineInfo;
  return machineinfo_;
}
inline ::lol::MMachineInfo* Db2GameLogin::release_machineinfo() {
  clear_has_machineinfo();
  ::lol::MMachineInfo* temp = machineinfo_;
  machineinfo_ = NULL;
  return temp;
}
inline void Db2GameLogin::set_allocated_machineinfo(::lol::MMachineInfo* machineinfo) {
  delete machineinfo_;
  machineinfo_ = machineinfo;
  if (machineinfo) {
    set_has_machineinfo();
  } else {
    clear_has_machineinfo();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace lol

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lol::CSProtocol>() {
  return ::lol::CSProtocol_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lol::ESvrType>() {
  return ::lol::ESvrType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_simple_2eproto__INCLUDED
